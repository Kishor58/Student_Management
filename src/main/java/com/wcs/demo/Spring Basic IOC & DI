What is Spring?
Spring is a popular Java framework used to build Java applications.
It provides comprehensive infrastructure support for developing Java applications.
In simple terms, Spring makes Java development easier and more efficient.

Why Use Spring?
1.It simplifies Java development by providing features like dependency injection,
aspect-oriented programming, and data access.

2.It allows you to create robust, maintainable applications with a lot of standardized infrastructure.

3.Spring is known for modularity—you can pick and choose the parts you need for your project.

Key Concepts in Spring
Here are some important concepts in Spring, explained step-by-step:

1. Inversion of Control (IoC)
In traditional programming, you create and manage all the objects yourself. For example,
if you need a class to do some work, you manually create an instance of that class.

Inversion of Control (IoC) means that Spring is in control of creating and managing your objects,
not you. Spring will create objects when you need them and give them to you when required.

Example:
Without IoC:

public class Car {
    private Engine engine;

    public Car() {
        // You create the engine manually
        this.engine = new Engine();
    }
}
With IoC (Spring will create the engine for you):

@Component
public class Car {
    private final Engine engine;

    @Autowired
    public Car(Engine engine) {
        this.engine = engine;
    }
}

****************************************************************************************************
2. Dependency Injection (DI)
Dependency Injection (DI) is a type of IoC. Instead of the class creating its own dependencies (like the Engine in the example), Spring injects those dependencies for you. There are three types of DI:

Constructor-based DI: Dependencies are provided through the class constructor.

Setter-based DI: Dependencies are provided using setter methods.

Field-based DI: Dependencies are injected directly into fields using annotations.

Example: Constructor-based DI

@Component
public class Car {
    private final Engine engine;

    @Autowired
    public Car(Engine engine) {
        this.engine = engine;
    }
}
Example: Setter-based DI

@Component
public class Car {
    private Engine engine;

    @Autowired
    public void setEngine(Engine engine) {
        this.engine = engine;
    }
}

****************************************************************************************************

3. Beans in Spring
In Spring, a Bean is simply a Java object that Spring manages. Beans are created, configured, and managed by the Spring container (the ApplicationContext).

A bean can be any object in your application (e.g., Car, Engine, StudentService).

Spring manages the lifecycle of beans (i.e., creation, injection, and destruction).

Example of Bean creation in Spring:

@Component
public class Engine {
    public Engine() {
        System.out.println("Engine created!");
    }
}
How to Define a Bean:
Use @Component annotation to tell Spring that the class should be managed as a bean.

Use @Service, @Repository, @Controller as specialized annotations for specific purposes in your app.

**********************************************************************************************************************

4. ApplicationContext
The ApplicationContext is the heart of the Spring framework. It is a container that holds all the beans in your application.

When you need a bean (object) in your application, you ask the ApplicationContext to provide it.

Example:

import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class MainApp {
    public static void main(String[] args) {
        // Create the Spring application context (container)
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext("com.example");

        // Ask Spring for a bean (Car in this case)
        Car car = context.getBean(Car.class);

        // Use the car object
        System.out.println(car);

        // Close the context when done
        context.close();
    }
}

************************************************************************************************************************

5. Bean Lifecycle
Spring manages the lifecycle of beans, from their creation to their destruction.

The lifecycle includes these steps:

Instantiation: Spring creates the bean.

Dependency Injection: Spring injects dependencies into the bean.

Initialization: Spring calls any initialization method (@PostConstruct).

Destruction: Spring calls the destroy method (@PreDestroy) when the context is closed.

Example of Bean Lifecycle Methods:

@Component
public class Car {

    @PostConstruct
    public void init() {
        System.out.println("Car is initialized.");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("Car is destroyed.");
    }
}

***************************************************************************************************************

6. Bean Scopes in Spring
A bean’s scope defines how long it lasts in the application. There are different scopes:

Singleton (default): One instance for the entire application.

Prototype: A new instance every time you ask for the bean.

Request: A new instance for each HTTP request (for web apps).

Session: A new instance for each HTTP session (for web apps).

Example: Singleton Scope (default)

@Component
public class Engine {
    public Engine() {
        System.out.println("Singleton Engine created.");
    }
}
Every time you ask for an Engine, Spring will give the same instance.

***************************************************************************************************************

7. Autowiring
Autowiring is a way to tell Spring to automatically inject the correct dependencies. You can use @Autowired to mark where you want Spring to inject the dependencies.

Types of Autowiring:
By Type: Spring will inject the dependency based on the type of the field.

By Name: Spring will inject the dependency based on the name of the field.

Constructor-based: Spring will inject dependencies via the constructor.

Example:

@Component
public class Car {
    @Autowired
    private Engine engine;  // Spring will inject an Engine bean automatically.
}
***************************************************************************************************************

8. Spring Configuration with Annotations
In Spring, you can define beans in two main ways:

Java-based Configuration (using @Configuration and @Bean).

Annotation-based Configuration (using @Component, @Service, etc.).

Example of Java-based configuration:

@Configuration
@ComponentScan("com.example")
public class AppConfig {
    // Configuration class where beans are defined
}
***************************************************************************************************************

Steps to Configure Beans with XML
Create an XML Configuration File (e.g., beans.xml).

Load the XML Configuration using ClassPathXmlApplicationContext.

Define your Beans in the beans.xml file.

1. Create the XML Configuration File (beans.xml)
You can configure the Car and Engine beans inside the XML configuration file.

beans.xml:file

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- Define the Car bean -->
    <bean id="car" class="com.example.Car">
        <!-- Inject the Engine bean into the Car bean -->
        <property name="engine" ref="engine" />
    </bean>

    <!-- Define the Engine bean -->
    <bean id="engine" class="com.example.Engine"/>
</beans>
In this XML file:

The <bean> tags define your beans (Car and Engine).

The ref="engine" tells Spring to inject the engine bean into the Car bean.

2. Modify Your Java Class to Load the XML Configuration
Now that the beans are defined in XML, you need to load them using ClassPathXmlApplicationContext instead of AnnotationConfigApplicationContext. Here's the modified version of your MainApp:

MainApp.java:

import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.example.Car;

public class MainApp {
    public static void main(String[] args) {
        // Load the XML configuration
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");

        // Ask Spring for a bean (Car in this case)
        Car car = context.getBean(Car.class);

        // Use the car object
        System.out.println(car);

        // Close the context when done
        context.close();
    }
}
In this code:

ClassPathXmlApplicationContext("beans.xml") loads the XML configuration.

Spring will create the Car and Engine beans, and inject the Engine bean into the Car bean, based on the XML configuration.